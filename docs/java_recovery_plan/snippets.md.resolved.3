# Java Ironclad Patterns (Snippets)

## Controller Pattern

```java
@RestController
@RequestMapping("/api/v1/resource-name") // TODO: Change path
@RequiredArgsConstructor
public class ResourceController {

    // private final ResourceService service; // TODO: Uncomment when Service is ready

    /**
     * Registration / Creation
     */
    @PostMapping
    public ResponseEntity<Void> create(@RequestBody @Valid CreateRequest request) {
        // service.create(request);
        return ResponseEntity.status(HttpStatus.CREATED).build();
    }

    // TODO: Add DTO classes (inner static class or separate file)
    // public record CreateRequest(@NotBlank String name) {}
}
```

### Key Points
1.  **Annotations**: `@RestController`, `@RequestMapping`, `@RequiredArgsConstructor` are the "Holy Trinity". Always write them first.
2.  **Constructor Injection**: `@RequiredArgsConstructor` (Lombok) handles dependency injection automatically for `final` fields.
3.  **Input Validation**: Always use `@RequestBody` and `@Valid` together for POST/PUT.
4.  **Response**: Return `ResponseEntity<T>`. Use `Void` if no body is returned.

## Service Pattern

```java
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true) // Default to read-only
public class ResourceService {

    // private final ResourceRepository repository;

    /**
     * Create (Write operation)
     */
    @Transactional // Override for write
    public void create(CreateRequest request) {
        // Entity entity = new Entity(request.name());
        // repository.save(entity);
    }

    /**
     * Read (Read-only operation)
     */
    public ResourceResponse findById(Long id) {
        // return repository.findById(id)
        //     .map(this::toResponse)
        //     .orElseThrow(() -> new ResourceNotFoundException("Resource not found with id: " + id));
        return null; // dummy
    }
}
```

### Key Points
1.  **Annotations**: `@Service`, `@RequiredArgsConstructor`.
2.  **Transaction Management**:
    *   Class level: `@Transactional(readOnly = true)` (Safety first! Prevents accidental writes).
    *   Write methods: `@Transactional` (Override to allow writes).
3.  **Exception Handling**: Use `.orElseThrow()` for clean 404 handling.

## Entity Pattern

```java
@Entity
@Table(name = "resources")
@Getter
@NoArgsConstructor
@AllArgsConstructor
public class Resource {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    // Constructor for creation (without id)
    public Resource(String name) {
        this.name = name;
    }
}
```

### Key Points
1.  **Annotations**: `@Entity`, `@Table(name = "...")`.
2.  **ID**: `@Id`, `@GeneratedValue(strategy = GenerationType.IDENTITY)` for auto-increment.
3.  **Lombok**: `@Getter`, `@NoArgsConstructor`, `@AllArgsConstructor` for boilerplate reduction.
4.  **Custom Constructor**: Add a constructor without `id` for creating new entities.

## Repository Pattern

```java
public interface ResourceRepository extends JpaRepository<Resource, Long> {
    // Spring Data JPA generates implementations automatically
    
    // Custom query examples (optional):
    // Optional<Resource> findByName(String name);
    // List<Resource> findByNameContaining(String keyword);
}
```

### Key Points
1.  **Extends JpaRepository**: `JpaRepository<Entity, ID>` provides CRUD methods automatically.
2.  **No @Repository needed**: Spring detects it automatically.
3.  **Method naming convention**: Spring generates queries from method names (e.g., `findByName`).

## Exception Handling Pattern

### Custom Exception
```java
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}
```

### Global Exception Handler
```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFoundException(ResourceNotFoundException ex) {
        ErrorResponse error = new ErrorResponse(
            ex.getMessage(), 
            HttpStatus.NOT_FOUND.value(), 
            LocalDateTime.now()
        );
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }
    
    // Can add more exception handlers here
}

record ErrorResponse(String message, int status, LocalDateTime timestamp) {}
```

### Key Points
1.  **@RestControllerAdvice**: Global exception handler for all controllers.
2.  **@ExceptionHandler**: Catches specific exception types.
3.  **Unified Error Response**: Consistent error format across the entire API.
4.  **HTTP Status Codes**: Map exceptions to appropriate status codes (404, 400, 500, etc.).

